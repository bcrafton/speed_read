
#include "pim.h"

Layer::Layer(int* x, int* w, int* y, Params* params, int* block_map) {
  this->params = params;
  this->block_map = block_map;
  
  this->blocks = new Block*[params->B];
  for (int i=0; i<params->B; i++) {
    int block_id = block_map[i];
    this->blocks[i] = new Block(block_id, x, w, y, params); 
  }
  
  this->params->D = this->params->B / this->params->NWL;
  
  this->row_map = new int[this->params->D]();
  this->row_queue = 0;
  
  for (int i=0; i<this->params->D; i++) {
    this->row_map[i] = this->row_queue;
    this->row_queue++;
  }
}

/*
void Layer::pim() {
  int* block_done = new int[this->params->B]();
  
  int done = 0;
  while (!done) {
    this->params->metrics[METRIC_CYCLE]++;

    done = 1;
    for (int b=0; b<this->params->B; b++) {

      int row = this->row_map[b];
      int block_row = this->block_map[b];
      
      done &= block_done[b];
      
      // we add B*NBL incorrect stalls.
      // we add 1 incorrect cycle.
      if (block_done[b]) {
        this->params->metrics[METRIC_STALL] += this->params->NBL;
        continue;
      }
      else {
        this->params->metrics[METRIC_BLOCK_CYCLE + block_row] += 1;
      }

      int ret = this->blocks[b]->pim(row);
      if (ret) {
        int next_row = this->row_queue[block_row];
        if (next_row < this->params->R) {
          this->row_map[b] = next_row;
          this->row_queue[block_row]++;
        }
        else {
          block_done[b] = 1;
        }
      }
    } // for (int b=0; b<this->params->B; b++) {
  } // while (!done) {
}
*/

void Layer::pim_sync() {
  
  int* matrix_done = new int[this->params->D]();
  int* block_done = new int[this->params->B]();
  
  int done = 0;
  while (!done) {
    this->params->metrics[METRIC_CYCLE]++;

    for (int d=0; d<this->params->D; d++) { 
      int row = this->row_map[d];

      for (int block_row=0; block_row<this->params->NWL; block_row++) {
        int b = d * this->params->NWL + block_row;
        if (block_done[b]) {
          this->params->metrics[METRIC_STALL] += this->params->NBL;
          continue;
        }
        else {
          this->params->metrics[METRIC_BLOCK_CYCLE + block_row] += 1;
        }
        block_done[b] = this->blocks[b]->pim(row);
      } // for (int block_row=0; block_row<NWL; block_row++) {   

      int block_sync = 1;
      for (int block_row=0; block_row<this->params->NWL; block_row++) {
        int b = d * this->params->NWL + block_row;
        block_sync = block_sync & block_done[b];
      }

      if (block_sync) {      
        int next_row = this->row_queue;
        if (next_row < this->params->R) {
          this->row_map[d] = next_row;
          this->row_queue++;
          
          for (int block_row=0; block_row<this->params->NWL; block_row++) {
            int b = d * this->params->NWL + block_row;
            block_done[b] = 0;
          }
        }
        else {
          matrix_done[d] = 1;
          int matrix_sync = 1;
          for (int i=0; i<this->params->D; i++) {
            matrix_sync = matrix_sync & matrix_done[i];
          }
          done = matrix_sync;
        }
      }

    } // for (int d=0; d<D; d++) { 
  } // while (!done) {
}








